---
title: 'An Optimization for RWLE-based FHE'
date: 2024-06-26
permalink: /posts/2024/06/zinc/
tags:
  - cryptography
  - high-performance-computing
---

For my first foray into the world of academic research, I decided to delve into the topic of cryptography, and in particular homomorphic encryption. I worked with Professor Dongfang Zhao of the [HPDIC Lab](https://hpdic.github.io/) at the University of Washington, studying optimizations (both at the system level and abstract level) for homomorphic encryption schemes. At the end of it all, I managed to ideate and implement a very simple optimization for a certain family of homomorphic encryption schemes that reduces encryption time by half, and could be even more depending on future work! While not published, the paper is available [here](https://arxiv.org/abs/2408.07304) for those interested.

## Homomorphic Encryption

To give a very short overview of what homomorphic encryption is, it's a good idea to understand the motivation behind it first. There are plenty of places online that we store information today. Cloud services range from storing financial or health data to training machine learning models. These are all sensitive, relating to privacy laws and simple human decency, but how can you trust the cloud services if you are not the administrator of the system from start to finish? Simple answer is, you can't really, and eventually you'll have to rely on some level of faith that there are no malicious actors on the other end of your data (related: [Reflections on Trusting Trust](https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf)). 

So, one solution could be to introduce a layer of encryption before sending off that data. Now you have a second problem: what if I want to compute something on that data? For example, taking an average of the salaries that are at my company. Your average cryptographic scheme doesn't permit these sort of arithmetic operations. Classically, a public-key scheme consists of a tuple of algorithms \\((Gen, Enc, Dec)\\) with the restriction that for any pair \\(pk, sk\\) produced by \\(Gen\\), we have \\(Dec(sk, Enc(pk, m)) = m\\).

This is where homomorphic encryption (HE) takes center stage. An HE scheme will tack on an extra algorithm(s) that allow you to perform certain functions given ciphertexts as input. To keep it simple, I'll imagine that homomorphic addition is specified by \\(\oplus\\), with the condition that 

\\[ Dec(sk, Enc(pk, m_1) \oplus \Enc(pk, m_2)) = m_1 + m_2 \\].

You can imagine how this might look for other operations as well. The mathematics of this is based in group theory, but won't be necessary for this exposition.